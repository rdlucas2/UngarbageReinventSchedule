<!DOCTYPE html>
<html>

<head>
    <title>
        Ungarbage Event Calendar
    </title>
    <link href='https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css' rel='stylesheet'>
    <link href='https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css' rel='stylesheet'>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fullcalendar-scheduler@5.11.3/main.css">
    <script src="https://cdn.jsdelivr.net/npm/fullcalendar-scheduler@5.11.3/main.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            var calendar = null;
            var calendarEl = document.getElementById('calendar');
            var overflowEl = document.getElementById('overflow');
            var refreshEl = document.getElementById("refresh");
            var legendEl = document.getElementById('legend');
            var tokenEl = document.getElementById('token');
            var overflowTotalEl = document.getElementById('overflowTotal');
            var currentDate = new Date();
            var vegasOffset = getTimeZoneOffset(currentDate, 'America/Los_Angeles');
            var localOffset = getTimeZoneOffset(currentDate, Intl.DateTimeFormat().resolvedOptions().timeZone);
            var offsetFromLosAngelesTime = (vegasOffset - (((vegasOffset - localOffset) / 60) > 12 ? localOffset - 60 : localOffset)) * 60 * 1000; //for New York, should be = 10800000

            const indexedDB =
                window.indexedDB ||
                window.mozIndexedDB ||
                window.webkitIndexedDB ||
                window.msIndexedDB ||
                window.shimIndexedDB;

            if (!indexedDB) {
                alert("IndexedDB could not be found in this browser, it is required to use this application.");
            }

            var stringToColor = (string, saturation = 100, lightness = 75) => {
                let hash = 0;
                for (let i = 0; i < string.length; i++) {
                    hash = string.charCodeAt(i) + ((hash << 5) - hash);
                    hash = hash & hash;
                }
                result = `hsl(${(hash % 360)}, ${saturation}%, ${lightness}%)`;
                return result;
            }

            function getTimeZoneOffset(date, timeZone) {
                let iso = date.toLocaleString('en-CA', { timeZone, hour12: false }).replace(', ', 'T');
                iso += '.' + date.getMilliseconds().toString().padStart(3, '0');
                //another hack - time was showing as 24:41... any value over 24 is invalid though
                tmp = iso.split('T')
                if (tmp[1].startsWith("24")) {
                    t = tmp[1].split(":");
                    iso = `${tmp[0]}T00:${t[1]}:${t[2]}`
                }
                const lie = new Date(iso + 'Z');
                return -(lie - date) / 60 / 1000;
            }

            function clearElement(element) {
                while (element.firstChild) {
                    element.removeChild(element.firstChild);
                }
            }

            function displayCalendar(events, resources) {
                let calEvents = [];
                for (var i = 0; i < events.length; i++) {
                    resourceId = `${events[i].venue.name} ${events[i].room.name}`
                    //This is a very hacky way to do this, but I didn't want to use npm and webpack or some other build system for the frontend
                    let isNotConferenceTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone !== 'America/Los_Angeles'
                    calEvent = {
                        id: i + 1,
                        start: isNotConferenceTimezone ? (events[i].startTime - offsetFromLosAngelesTime) : events[i].startTime,
                        end: isNotConferenceTimezone ? (events[i].endTime - offsetFromLosAngelesTime) : events[i].endTime,
                        title: events[i].name,
                        resourceId: resourceId,
                        backgroundColor: stringToColor(events[i].sessionType.name),
                        textColor: '#000000',
                        borderColor: '#000000'
                    };
                    calEvents.push(calEvent);
                }
                calendar = new FullCalendar.Calendar(calendarEl, {
                    schedulerLicenseKey: 'CC-Attribution-NonCommercial-NoDerivatives',
                    themeSystem: 'bootsrap5',
                    initialView: 'resourceTimeline',
                    initialDate: '2022-11-28', //Date.now(),
                    resources: resources,
                    headerToolbar: {
                        left: 'prev,next today',
                        center: 'title',
                        right: 'dayGridMonth,timeGridWeek,timeGridDay,resourceTimeline,resourceTimeGridDay'
                    },
                    events: calEvents
                });
                calendar.render();
            }

            function displayLegend(events) {
                let legend = [];
                for (var i = 0; i < events.length; i++) {
                    if (legend.findIndex(x => x.label === events[i].sessionType.name) < 0) {
                        legend.push({
                            label: events[i].sessionType.name,
                            color: stringToColor(events[i].sessionType.name)
                        });
                    }
                }
                clearElement(legendEl);
                for (var i = 0; i < legend.length; i++) {
                    legendEl.innerHTML += `<li style="float:left;">${legend[i].label} <div style="background-color: ${legend[i].color}; width:20px; height:20px; text-indent: -9999px;">x</div></li>`;
                }
            }

            function displayOverflow(i, d) {
                clearElement(overflowEl);
                for (var i = 0; i < localStorage.length; i++) {
                    key = localStorage.key(i);
                    if (key.startsWith('overflow')) {
                        var li = document.createElement('li');
                        var pre = document.createElement('pre');
                        pre.appendChild(document.createTextNode(JSON.stringify(JSON.parse(localStorage.getItem(key)), null, 4)));
                        li.appendChild(pre);
                        overflowEl.appendChild(li);
                    }
                }
            }

            function displayOverflowTotal() {
                overflowTotalEl.innerText = overflowEl.getElementsByTagName('li').length.toString();
            }

            function displayAll(events) {
                let resources = JSON.parse(localStorage.getItem('resources'));
                displayCalendar(events, resources);
                displayLegend(events);
                displayOverflow();
                displayOverflowTotal();
            }

            async function prepDataForLocalStorage() {
                localStorage.clear();
                let rawEvents = await loadFromAws();
                let d = rawEvents.data;
                let events = [];
                let resources = [];
                for (let i = 0; i < d.length; i++) {
                    resourceId = null;
                    let isOverflow = false;
                    if (d[i].venue && d[i].room) {
                        resourceId = `${d[i].venue.name} ${d[i].room.name}`;
                        if (resources.findIndex(x => x.id === resourceId) < 0) {
                            resources.push({
                                id: resourceId,
                                title: resourceId
                            });
                        }
                    } else {
                        isOverflow = true;
                    }
                    if (d[i].startTime && d[i].endTime) {
                        d[i].id = i;
                        if (!(d[i].venue && d[i].room)) {
                            d[i].venue = {};
                            d[i].venue.name = "No";
                            d[i].room = {};
                            d[i].room.name = "Room";
                        }
                        events.push(d[i]);
                    } else {
                        isOverflow = true;
                    }
                    if (isOverflow) {
                        localStorage.setItem(`overflow${i}`, JSON.stringify(d[i]));
                    }
                }
                resources.push({
                    id: "No Room",
                    title: "No Room"
                })
                localStorage.setItem('resources', JSON.stringify(resources));
                return events
            }

            document.getElementById('filter').addEventListener('change', function () {
                console.log('You selected: ', this.value);
                loadEventsFromLocal(this.value);
            });

            document.getElementById('overflowToggle').addEventListener('click', function () {
                if (overflowEl.style.display === "none") {
                    overflowEl.style.display = "block";
                } else {
                    overflowEl.style.display = "none";
                }
            });

            document.getElementById('loadEvents').addEventListener('click', function () {
                const request = indexedDB.open("EventDatabase", 1);

                request.onerror = function (event) {
                    console.error("An error occurred with IndexedDB");
                    console.error(event);
                };

                request.onupgradeneeded = function () {
                    const db = request.result;
                    const store = db.createObjectStore("events", { keyPath: "id" });
                };

                request.onsuccess = function () {
                    prepDataForLocalStorage().then(events => {
                        console.log(events.length);
                        const db = request.result;
                        const clearTransaction = db.transaction("events", "readwrite").objectStore("events").clear();
                        clearTransaction.onsuccess = () => {
                            const transaction = db.transaction("events", "readwrite");
                            const store = transaction.objectStore("events");
                            for (var i = 0; i < events.length; i++) {
                                store.put(events[i]);
                            }
                            transaction.oncomplete = function () {
                                db.close();
                            };
                            displayAll(events);
                        }
                        clearTransaction.onerror = (err) => {
                            console.log(err);
                        }
                    });
                };
            });

            async function loadFromAws() {
                let next_token = null;
                let results = [];
                while (true) {
                    let response = await fetch('https://api.us-east-1.prod.events.aws.a2z.com/attendee/graphql', {
                        method: 'POST',
                        headers: {
                            "Authorization": `Bearer ${tokenEl.value}`,
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify(
                            {
                                "operationName": "listAttendeeSessions",
                                "variables": {
                                    "input": {
                                        "eventId": "53b5de8d-7b9d-4fcc-a178-6433641075fe",
                                        "maxResults": 97,
                                        "nextToken": next_token,
                                    }
                                },
                                "query": "query listAttendeeSessions($input: ListAttendeeSessionsInput!) {\n  listAttendeeSessions(input: $input) {\n    results {\n      ...SessionFragment\n      __typename\n    }\n    totalCount\n    nextToken\n    __typename\n  }\n}\n\nfragment SessionFragment on Session {\n  ...SessionFieldFragment\n  isConflicting {\n    reserved {\n      eventId\n      sessionId\n      isPaidSession\n      __typename\n    }\n    waitlisted {\n      eventId\n      sessionId\n      isPaidSession\n      __typename\n    }\n    __typename\n  }\n  __typename\n}\n\nfragment SessionFieldFragment on Session {\n  action\n  alias\n  createdAt\n  description\n  duration\n  endTime\n  eventId\n  isConflicting {\n    reserved {\n      alias\n      createdAt\n      eventId\n      name\n      sessionId\n      type\n      __typename\n    }\n    waitlisted {\n      alias\n      createdAt\n      eventId\n      name\n      sessionId\n      type\n      __typename\n    }\n    __typename\n  }\n  isEmbargoed\n  isFavoritedByMe\n  isPaidSession\n  level\n  location\n  myReservationStatus\n  name\n  sessionId\n  startTime\n  status\n  type\n  capacities {\n    reservableRemaining\n    waitlistRemaining\n    __typename\n  }\n  customFieldDetails {\n    name\n    type\n    visibility\n    fieldId\n    ... on CustomFieldValueFlag {\n      enabled\n      __typename\n    }\n    ... on CustomFieldValueSingleSelect {\n      value {\n        fieldOptionId\n        name\n        __typename\n      }\n      __typename\n    }\n    ... on CustomFieldValueMultiSelect {\n      values {\n        fieldOptionId\n        name\n        __typename\n      }\n      __typename\n    }\n    ... on CustomFieldValueHyperlink {\n      text\n      url\n      __typename\n    }\n    __typename\n  }\n  package {\n    itemId\n    __typename\n  }\n  price {\n    currency\n    value\n    __typename\n  }\n  venue {\n    name\n    __typename\n  }\n  room {\n    name\n    __typename\n  }\n  sessionType {\n    name\n    __typename\n  }\n  speakers {\n    speakerId\n    jobTitle\n    companyName\n    user {\n      firstName\n      lastName\n      __typename\n    }\n    __typename\n  }\n  tracks {\n    name\n    __typename\n  }\n  __typename\n}\n",
                            }
                        )
                    });
                    let result = await response.json();
                    events = result.data.listAttendeeSessions.results;
                    results = results.concat(events);
                    next_token = result.data.listAttendeeSessions.nextToken;
                    if (!next_token) {
                        break;
                    }
                }
                return {
                    "count": results.length,
                    "data": results
                };
            }

            function loadEventsFromLocal(filter) {
                const req = indexedDB.open("EventDatabase", 1);

                req.onerror = function (event) {
                    console.error("An error occurred with IndexedDB");
                    console.error(event);
                };

                req.onsuccess = (e) => {
                    // Create the DB connection
                    let localdb = req.result;
                    let t;
                    try {
                        t = localdb.transaction('events', 'readonly').objectStore('events').getAll();
                    } catch (error) {
                        console.log(error);
                        indexedDB.deleteDatabase('EventDatabase');
                        alert('Locally stored events do not exist, you must get your bearer token and use the (re)load events button');
                        return;
                    }
                    t.onsuccess = () => {
                        const events = t.result;
                        let filteredEvents = null;
                        switch (filter) {
                            case 'reservable':
                                filteredEvents = events.filter(x => x.action === 'RESERVABLE');
                                break;
                            case 'waitlistable':
                                filteredEvents = events.filter(x => x.action === 'WAITLISTABLE');
                                break;
                            case 'reserved':
                                filteredEvents = events.filter(x => x.action === 'RESERVED');
                                break;
                            case 'favorites':
                                filteredEvents = events.filter(x => x.isFavoritedByMe);
                                break;
                            default:
                                console.log(events);
                                displayAll(events);
                                return;
                        }
                        console.log(filteredEvents);
                        displayAll(filteredEvents);
                    }
                    t.oncomplete = function () {
                        localdb.close();
                    };
                };
            }

            loadEventsFromLocal();
        });
    </script>
</head>

<body>
    <label for="filter">Filter events:</label>
    <select id="filter" name="filter">
        <option value="all">all</option>
        <option value="reserved">reserved</option>
        <option value="reservable">reservable</option>
        <option value="favorites">favorites</option>
        <option value="waitlistable">wait list available</option>
    </select>
    <label for="token">Bearer Token for AWS Lambda:</label>
    <input type="password" name="token" id="token"><button id="loadEvents">(re)load events</button>
    <p>Your events are saved to local storage in your browser. You must provide your bearer token (found by using
        browser dev tools on the re:invent event page). Use the (re)load events button to initialize events, or reload
        after you make a change on the event site.</p>
    <p><a href="https://portal.awsevents.com/events/reInvent2022/registration">re:invent 2022 login page</a></p>
    <ul id="legend" style="list-style-type: none; padding-right:20px"></ul>
    <div id="calendar" style="clear:left;"></div>
    <button id="overflowToggle">Show/Hide Events Without Venue or Times (<span id="overflowTotal"></span>
        Total)</button>
    <ul id="overflow" style="display:none;"></ul>
</body>

</html>